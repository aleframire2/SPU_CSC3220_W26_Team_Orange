# NarrativeLink Database Schema

## Overview
 This document outlines the database design for **NarrativeLink**.  The schema is implemented using **SQLite**  to ensure the application remains strictly offline and single-user.

 The design separates the "Game Engine" data (Word Chains and timing) from the "Narrative" data (Stories and drafts), allowing for granular analytics on writing speed and vocabulary usage.

## Entity Dictionary

### 1. Story
 **Description:** Represents the final narrative output generated by the user during the Narrative Synthesis phase. This table stores the creative content and calculated post-session metrics.

| Attribute | Type | Constraints | Description |
| :--- | :--- | :--- | :--- |
| `story_id` | INTEGER | **PK** | Unique identifier for the story draft. |
| `title` | TEXT | | Title of the narrative (default or user-edited). |
| `content` | TEXT | | The main body of the story text. |
| `created_at` | DATETIME | | Timestamp of session creation. |
| `updated_at` | DATETIME | |  Timestamp of the last edit (supports CRUD). |
| `total_word_count` | INTEGER | | Cached word count for the story. |
| `total_time_elapsed` | INTEGER | | Total seconds spent in the writing phase. |
| `flesch_score` | REAL | |  Calculated Flesch Reading Ease score (0-100). |

### 2. WordChain
 **Description:** Represents a specific "Chain Reaction" gameplay session. It acts as the bridge between the raw gameplay data and the resulting story.

| Attribute | Type | Constraints | Description |
| :--- | :--- | :--- | :--- |
| `chain_id` | INTEGER | **PK** | Unique identifier for the game session. |
| `story_id` | INTEGER | **FK**, UNIQUE | Links to the `Story` table. Enforces a 1:1 relationship. |

### 3. ChainWord
 **Description:** Stores the individual links (words) forged during a Chain Reaction session.
* **Purpose:** Captures the sequence of words and the speed at which the user associated them.  This data drives the "Session Analytics" feature.

| Attribute | Type | Constraints | Description |
| :--- | :--- | :--- | :--- |
| `chain_id` | INTEGER | **PK, FK** | Part of Composite PK. Links to the parent session. |
| `sequence_order` | INTEGER | **PK** | Part of Composite PK. The position of the word in the chain. |
| `word_id` | INTEGER | **FK** | The specific word used (references `WordPool`). |
| `time_taken_ms` | INTEGER | |  Time in milliseconds taken to type/link this specific word. |

### 4. WordPool
 **Description:** The local dictionary of valid words available for the random generator.
* **Purpose:** Supports the "Chain Reaction Engine" by providing random anchor words.

| Attribute | Type | Constraints | Description |
| :--- | :--- | :--- | :--- |
| `word_id` | INTEGER | **PK** | Unique identifier for the word. |
| `word_text` | TEXT | UNIQUE | The actual string representation of the word. |

---

## Entity Relationships

### Story ↔ WordChain (1:1)
* **Notation:** `Story ||--|| WordChain`
*  **Logic:** A specific WordChain serves as the mandatory framework for exactly one Story. The unique foreign key constraint ensures that a chain is not reused for multiple different stories.

### WordChain ↔ ChainWord (1:Many)
* **Notation:** `WordChain ||--|{ ChainWord`
* **Logic:** One game session (`WordChain`) consists of multiple individual words (`ChainWord`).

### WordPool ↔ ChainWord (1:Many)
* **Notation:** `WordPool ||--o{ ChainWord`
* **Logic:** A single word from the dictionary can appear in many different game sessions over time. This structure efficiently stores the ID rather than duplicating the text string.

---

## Key Design Decisions

1.  **Composite Primary Key for `ChainWord`:**
    * We utilize a composite key (`chain_id` + `sequence_order`) for the `ChainWord` table. This guarantees that within a single game session, two words cannot occupy the same "slot" (e.g., there can only be one "3rd word").

2.  **Performance Analytics (`time_taken_ms`):**
    * Instead of just storing the words, we store the `time_taken_ms` for *each* link.  This allows the application to calculate the user's "average linking speed" as required by the Session Analytics feature.

3.  **Local Readability Storage:**
    * The `flesch_score` is stored directly on the `Story` table.  Since the calculation is done locally via a heuristic algorithm, persisting this score avoids re-calculating it every time the user views their Local Archive.
